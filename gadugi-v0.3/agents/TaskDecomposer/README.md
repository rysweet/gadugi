# Task Decomposer Agent

The task-decomposer breaks down high-level tasks into manageable subtasks that can be executed by other agents.

## Purpose

This is the second vertical slice for Gadugi v0.3, validating multi-agent coordination. It demonstrates:
- Agent-to-agent workflow (orchestrator -> task-decomposer)
- Structured data exchange between agents
- Task breakdown with dependency management
- Foundation for parallel task execution

## Contract

### Inputs
- `task_description` (string): High-level task to decompose

### Outputs
- JSON object with structured task breakdown:
  - `original_task`: The input task
  - `tasks`: Array of subtasks with id, agent, task, dependencies
  - `parallel_groups`: Arrays of task IDs that can run in parallel

### Side Effects
- No file system changes
- No external network calls
- Pure analysis and transformation

## Usage

### Via Orchestrator (Recommended)
```python
from run_agent import run_agent
result = run_agent("task-decomposer", "Build a REST API")
tasks = json.loads(result["stdout"])
```

### Via Command Line
```bash
python run_agent.py task-decomposer "Build a web application"
```

### Via Demo Workflow
```bash
python demo_workflow.py "Create a mobile app"
```

## Output Structure

```json
{
  "original_task": "Build a REST API with authentication",
  "tasks": [
    {
      "id": "1",
      "agent": "code-writer", 
      "task": "Set up project structure",
      "dependencies": []
    },
    {
      "id": "2", 
      "agent": "code-writer",
      "task": "Create API endpoints", 
      "dependencies": ["1"]
    }
  ],
  "parallel_groups": [["1"], ["2"]]
}
```

## Implementation Notes

- Hybrid approach: Agent definition + Python implementation
- Pattern matching for common task types (API, app, etc.)
- Simple dependency chains (no complex DAG yet)
- Focuses on actionable subtasks
- Returns valid JSON for programmatic processing

## Agent Types Used

- **code-writer**: Implementation tasks
- **test-writer**: Testing tasks  
- **documentation**: Documentation tasks
- **deployment**: Infrastructure tasks

## Current Patterns

1. **API/Backend Tasks**: Project setup → Models → Endpoints → Tests
2. **App Tasks**: UI Layout → Functionality → Tests
3. **Generic Tasks**: Requirements → Implementation → Testing

## Limitations

- Basic pattern matching (not true AI analysis yet)
- Simple linear dependencies
- Limited agent type variety
- No complex branching or conditional logic

## Future Enhancements

Based on architect guidance, future versions may add:
- More sophisticated task analysis
- Complex dependency management
- Dynamic agent type discovery
- Integration with actual agent execution
- Learning from execution outcomes

## Regeneration

This component can be regenerated by:
1. Reading this specification
2. Implementing pattern matching for common task types  
3. Following JSON output contract
4. Testing with orchestrator integration
5. Validating with demo workflow

The core pattern is: analyze task → identify components → create dependencies → return JSON.